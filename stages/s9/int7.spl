//print "7 routine";
alias currentPID S0;
currentPID = (PTBR - 1024) / 8;
alias currentPCB S1;
currentPCB = READY_LIST + 32 * currentPID;
[ currentPCB + 1 ] = 0; // Set STATE to 0
alias i S3;
i=0;
while(i<8) do
	if([currentPCB + 15 + i*2 + 0] != -1) then
		[FILE_TABLE + [currentPCB + 15 + i*2 + 0]*2 + 1] = [FILE_TABLE + [currentPCB + 15 + i*2 + 0]*2 + 1] - 1;
		if([FILE_TABLE + [currentPCB + 15 + i*2 + 0]*2 + 1] == 0) then
			[FILE_TABLE + [currentPCB + 15 + i*2 + 0]*2 + 0] = -1;
		endif;
	endif;
	i = i + 1;
endwhile;
i=0;
while(i<4) do
	[PTBR + i*2 + 0] = -1;
	[PTBR + i*2 + 1] = "00";
i = i + 1;
endwhile;
alias pid S2;
alias pcb S4;
pid = currentPID + 1;

alias j S8;
i=0;
j=0;
while(1==1) do
	i=0;
	j=0;
	while(i<32) do
		if((([pcb + i*8] != 1) && ([pcb + i*8] != 2)) ||([pcb + i*8] == 0))then
			j = j+1;
		endif;
		i=i+1;
	endwhile;
	if(j > 31) then
	halt;
	endif;
	if(pid > 31) then
		pid = 0;
	endif;
	pcb = READY_LIST + 32 * pid;
	if([pcb + 1] == 1) then
		currentPID = pid;
		break;
	else
		pid = pid + 1;
	endif;	
endwhile;
if(pid == currentPID+1) then
	halt;
else
	alias PCB S5;
	PCB = pcb;
	[PCB + 1] = 2;
	BP = [PCB + 2];
	SP = [PCB + 3];
	PTBR = [PCB + 5];
	PTLR = [PCB + 6];
	R0 = [PCB + 7];
	R1 = [PCB + 8];
	R2 = [PCB + 9];
	R3 = [PCB + 10];
	R4 = [PCB + 11];
	R5 = [PCB + 12];
	R6 = [PCB + 13];
	R7 = [PCB + 14];
	SP = SP + 1; 
	alias newphysicalSP S2; 
	newphysicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512); 
	[ newphysicalSP ] = [ PCB + 4 ]; // Stores IP field value of PCB on the stack 
	ireturn;
endif;
halt;
